%!TEX root = ../main.tex

\chapter{Presentation of the project}

Type providers have significant benefits that are worth exploring in other programming languages. I have created a project that aims to approximate the benefits of type providers in Rust.

The project is divided into five crates\footnote{A crate is the equivalent of a library or a package in Cargo, Rust's package manager}, as well as a crate demonstrating the use of the main crate. Most important of these are one library -- a procedural macro -- and two binaries -- a command line interface and a web interface. Figure~\ref{fig:crates} shows how the crates depend on each other.

\begin{figure}[ht!]
\centering
\begin{tikzpicture}[>=stealth, thick, shorten >=1pt]
\graph [layered layout, grow=up, level distance=1.3cm, nodes={draw, rectangle, rounded corners}] {
"json\_typegen\_demo" -> "json\_typegen";
"json\_typegen" -> "json\_typegen\_derive";
"json\_typegen\_derive" ->[shorten >=6pt] "json\_typegen\_shared";
"json\_typegen\_cli" -> "json\_typegen\_shared";
"json\_typegen\_web" ->[shorten >=6pt] "json\_typegen\_shared";
};
\end{tikzpicture}
\caption{Internal dependencies in the project}
\label{fig:crates}
\end{figure}

\section{The procedural macro}

The crate «json_typegen» provides a procedural macro of the same name, ‹json_typegen›. This macro provides an interface very similar to the type providers from \fsharpdata.

\begin{listing}[ht!]
\begin{minted}{rust}
#[macro_use]
extern crate json_typegen;
extern crate serde_json;

json_typegen!("Point", r#"{ "x": 1, "y": 2 }"#);

fn main() {
    let mut p: Point =
        serde_json::from_str(r#"{ "x": 3, "y": 5 }"#).unwrap();
    println!("deserialized = {:?}", p);
    p.x = 4;
    let serialized = serde_json::to_string(&p).unwrap();
    println!("serialized = {}", serialized);
}
\end{minted}
\caption{Usage of the procedural macro}
\label{lst:typegenmacro}
\end{listing}

In listing~\ref{lst:typegenmacro} a minimal example of usage of the procedural macro ‹json_typegen› is shown. This example is provided in the project source as a demo crate, «json_typegen_demo». It is worth noting that the calls to ‹unwrap› unwraps result values assuming success, and will crash the program in the event of a serialization or deserialization failure. In a real world use case we would replace these calls with error handling code.

The procedural macro supports inline samples as shown, samples stored as local files and URLs that point to remote samples.

\subsection{Limitations compared to an actual type provider}
\label{sec:macro-limitations}

While the procedural macro looks like and in many ways works like a type provider, it is not a real type provider. For some features actual support for type providers in the compiler and the tooling would be necessary.

At the moment there is no tooling solution for Rust that provides autocomplete for types generated by procedural macros. There is reason to believe that this may change in the future. However, if this will happen at all, if it would work for the ‹json_typegen› macro specifically and when it would hypothetically be done is all mostly guesswork at this point.

Since this solution is only a procedural macro that is run at compile time and does not have knowledge of the rest of the program there is no way to implement code generation on demand that depends on how the type is used. A version of this feature would be possible to do with a procedural macro system, but would require making significant changes to the Rust compiler. It is also very possible that it is not desirable to change the macro system in this manner.

\subsubsection{Procedural macro hack}

Another limitation of the current implementation is that the macro can only be used once per scope. This is a consequence of the fact that, at the time of writing this, function-like procedural macros are currently not enabled on the stable version of the Rust compiler.

To work around this limitation ‹json_typegen› is actually a normal rule-based macro. The invocation of this macro expands to the declaration of a type that uses a custom derive that is implemented in «json_typegen_derive»\footnote{This hack is demonstrated in isolation, and described in more detail at \url{https://github.com/dtolnay/proc-macro-hack}}. Since the ordinary macro is unable to create new type names for each invocation, two invocations of the macro would create two (unused) types with the same name.

\begin{listing}[ht!]
\begin{minted}{rust}
mod point {
    json_typegen!("pub Point", "point_sample.json");
}

mod vector {
    json_typegen!("pub Vector", "vector_sample.json");
}

use point::*;
use vector::*;
\end{minted}
\caption{Workaround for the procedural macro hack}
\label{lst:hack-workaround}
\end{listing}

In my testing thus far I have not had a need to work around this limitation, but if necessary the easiest way is to wrap the macro invocation in module scopes, and if desired import the created types. Another workaround is to use «json_typegen_derive» directly. However in the near future\footnote{Tracking issue for procedural macros: \url{https://github.com/rust-lang/rust/issues/38356}} no hack should be needed as all as function-like procedural macros become available on the stable compiler.

\section{The command line interface}

The crate «json_typegen_cli» provides a binary, ‹json_typegen›, which is a command line interface to the same code generation as is used in the procedural macro.

\section{The web interface}

The procedural macro and the command line interface both require the user to download and compile a somewhat significant amount of code. In small projects where the sample can be assumed not to change this initial cost may for a lot of users seem to outweigh the benefits of the code generation.

Both of these kinds of interfaces are also quite bad interface-wise if the user wants to use a large number of configuration options. To counteract both of these problems I have made a web interface as a third way to use access the code generation logic.

The crate «json_typegen_web» provides a binary that both provides a web API for the code generation, as well as hosting the static HTML/JavaScript files providing a frontend to this API.

\placeholder{Demonstrate how CLI or web interface can be used together with proc-macro. Explain how this then gives autocomplete etc.}

\section{Shared code}

As seen in figure~\ref{fig:crates} the macro, web interface and CLI all depend on a common crate, «json_typegen_shared». This crate contains the actual inference and code generation logic. The following data flow is common to all three interfaces:

\begin{enumerate}
  \item Get the actual JSON text for the sample.
  \item Parse the JSON text into JSON values
  \item Infer type shapes from the JSON values
  \item Generate Rust code from the type shapes
\end{enumerate}

\section{Configurability}

\placeholder{Describe how the goal of configurability differs from \fsharpdata and the consequences of this.}

\placeholder{Add/remove derives}

\placeholder{Visibility}

\placeholder{Explain JSON pointers (Maybe in introduction instead?)}

\placeholder{Configuration/inference hints through JSON pointers}

\section{Editor plugins}

\placeholder{Describe idea behind \url{https://github.com/evestera/atom-json-typegen} and superficially how it works/can work.}
