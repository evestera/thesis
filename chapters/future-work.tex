%!TEX root = ../main.tex

\chapter{Future work}

\begin{picture}(0,0)
\put(190,50){\hbox{\includegraphics[width=5cm, angle=0, trim=20 20 20 20, clip]{ferris/longlist}}}
\end{picture}
\vspace{-1cm}

In this thesis project I have thus far only implemented code generation for JSON. The library \fsharpdata\footnote{\url{http://fsharp.github.io/FSharp.Data/}} has type providers for JSON, CSV, HTML and XML. Like \fsharpdata, the code generation in my project is generic over inferred types. Thus, writing similar projects in Rust for other data formats should be able to reuse large amounts of the code I have written. Considering the benefits and added complexity of multiple interfaces I do not think a single project like \fsharpdata\ is the right approach for an extension of my code.

\fsharpdata\ supports a solution for heterogeneous collections to avoid inferring any types for some cases. I have not implemented this functionality (or tagged any-types). Such functionality would be very useful in certain specific cases. A possible way to introduce this functionality while not coming into conflict with «Serde» would be to use enums for tagged any-types along with simple helper functions using ‹filter_map›.

«Serde» 1.0 was recently released and supports zero-copy deserialization. What this means is that if data is deserialized from something that is already in memory, no new memory is allocated on the heap, and the new data structure instead references the existing memory. In some cases this can be very beneficial, and it might be worthwhile to implement support for this feature in the code generated by «json_typegen». However, in most of my own trials of actually deserializing, I have been working with streams of data, and as such have allocated memory only for the end product, not the source I was deserializing from.

As mentioned in the introduction JSON is a schemaless data format. There is however a separate schema format -- JSON Schema -- that has emerged. It is likely that similar code generation techniques to those used in this project could be applied to JSON Schema. There are however some additional challenges when generating code for JSON Schema:

\begin{enumerate}
  \item It seems to me though that a lot of the people/websites actually using JSON Schema (often in Swagger/OpenAPI) don't actually use it according to the specification. As an example; many completely omit the "required" field that specify which fields of an object are not nullable. In my opinion this defeats some of the point of a schema, as it leaves us unable to generate code that is both safe and ergonomic without inspecting the data itself and making assumptions based on it.
  \item JSON Schema also has some challenges for code generation in that it can easily represent types which are very hard to represent (at least with serde, the most common serialization/deserialization library for Rust), so it may require actually writing the deserialization code more or less specifically for any hypothetical JSON Schema library. The references in JSON Schema also means that a naive tree walk is not quite enough (though not far from it).
\end{enumerate}

% OpenAPI

% Tagged JSON: https://www.tjson.org

\newpage
\section{Implementation state}
\label{sec:implementation-state}

Throughout this thesis I have written about how the project does work and ideally should work beyond the basic functionality. This section is meant as a quick reference to what state each mentioned configuration and extension of the implementation is in, without having to dig through discussion or code.

% green box
% \textcolor{green}{\rule{0.5cm}{0.5cm}}

\newcommand\ok{\checkmark}
\begin{center}
\renewcommand\arraystretch{1.2}
\begin{tabular}{l r c c c c c}
\textbf{Feature}          & \textbf{Relevant sections} & \rotatebox{45}{\textbf{Inference}}\kern-25pt & \rotatebox{45}{\textbf{Codegen}}\kern-25pt & \rotatebox{45}{\textbf{Macro}}\kern-15pt & \rotatebox{45}{\textbf{CLI}}\kern-5pt & \rotatebox{45}{\textbf{Web}}\kern-10pt \\ \hline
Basic inference algorithm & \ref{sec:shape-inference}                                & \ok & \ok & \ok & \ok & \ok \\
Type visibility           & \ref{sec:visibility}                                     & \ok & \ok & \ok & \ok & \ok \\
Field visibility          & \ref{sec:visibility}                                     & \ok & \ok & -   & -   & -   \\
Derive list               & \ref{sec:derive-list}, \ref{sec:use-of-derivable-traits} &     & \ok & -   & -   & \ok \\
Nullable collections      &                                                          &     & \ok & -   & -   & -   \\
Missing fields            &                                                          &     & \ok & -   & -   & -   \\
Unknown fields            &                                                          &     & \ok & -   & -   & -   \\
JSON Pointers             & \ref{sec:json-pointers}, \ref{sec:ext-json-pointers}     & -   & -   & -   & -   & -   \\
‹use_type›: shape         &                                                          & -   &     &     &     &     \\
‹use_type›: opaque        &                                                          & -   & -   &     &     &     \\
‹use_type›: map           & \ref{sec:ext-maps}                                       & -   & -   &     &     &     \\
‹use_type›: tuple         & \ref{sec:ext-tuples}                                     & -   & -   & -   & -   & -   \\
‹use_type›: string enum   &                                                          & -   & -   &     &     &     \\
‹use_type›: unsigned      &                                                          & -   & -   & -   & -   & -   \\
‹same_as›                 &                                                          & -   & -   &     &     &     \\
‹type_name›               &                                                          & -   & -   &     &     &     \\
‹pattern_type›            &                                                          & -   & -   &     &     &     \\
Macro syntax input        & \ref{sec:improving-synergy}                              &     &     &     & -   & -   \\
Macro syntax output       & \ref{sec:improving-synergy}                              &     &     &     & -   & -   \\
\multicolumn{7}{c}{} \\
\multicolumn{7}{c}{\textbf{Legend:} Complete: \ok\  Missing: -\ \  Not applicable: \ \ \textit{(blank)}}
\end{tabular}
\end{center}
